package main

import (
	"flag"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"archive/zip"

	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	log "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
)

var (
	phase          = flag.String("phase", "", "Phase of this plugin, either [setup,shutdown]")
	serviceAccount = flag.String("service-account", "", "Service account containing credentials for the GCP API")
	region         = flag.String("region", "", "GCP region")
	opvnConfig     = flag.String("ovpn-config", "", "OpenVPN Config")
	daemon         = flag.Bool("daemon", false, "daemonize OpenVPN")
	logger         logr.Logger
)

func main() {
	_ = serviceAccount
	_ = region

	opts := zap.Options{}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	log.SetLogger(zap.New(zap.UseDevMode(false), zap.UseFlagOptions(&opts)))
	logger = log.Log.WithName("gcve-setup")

	var err error
	if err = validate(); err != nil {
		logger.Error(err, "error validating input flags")
		os.Exit(1)
	}

	if *phase == "setup" {
		err = setupGCVE()
	} else if *phase == "shutdown" {
		err = shutdownGCVE()
	} else if *phase == "dummy" {
		logger.Info("Dummy invocation")
	}

	if err != nil {
		logger.Error(err, "error in phase processing", "phase", phase)
		os.Exit(1)
	}
}

func validate() error {
	if len(*phase) == 0 || (*phase != "setup" && *phase != "shutdown" && *phase != "dummy") {
		return errors.Errorf("--phase flag is `%s' and must be ['setup', 'shutdown', 'dummy']", *phase)
	}
	if *phase == "setup" && len(*opvnConfig) == 0 {
		return errors.Errorf("--ovpn-config flag is '%s' and must contain path to OpenVPN config zip from GCVE", *opvnConfig)
	}
	return nil
}

func setupGCVE() error {
	logger.Info("setupGCVE()")

	return nil
}

func shutdownGCVE() error {
	logger.Info("shutdownGCVE()")

	return nil
}

func setupVPN() error {
	logger.Info("Setting up GCVE environment")
	logger.Info("setup VPN")
	dst, err := ioutil.TempDir("/tmp", "openvpn")
	if err != nil {
		return err
	}

	// When OpenVPN is sublaunched with `--daemon`, it returns and allows the config files to be deleted well before they are used.
	// These credentials aren't particularly sensitive so it doesn't much matter.
	//defer func(path string) {
	//	_ = os.RemoveAll(path)
	//}(dst)

	if err = copyZip(*opvnConfig, dst); err != nil {
		return err
	}

	var oArgs = []string{}
	if _, err = os.Stat("/etc/openvpn/up.sh"); err == nil {
		if _, err = os.Stat("/etc/openvpn/down.sh"); err == nil {
			oArgs = append(oArgs, "--up", "/etc/openvpn/up.sh", "--down", "/etc/openvpn/down.sh")
		}
	}
	if *daemon {
		oArgs = append(oArgs, "--daemon")
	}

	cmd := exec.Command("openvpn", append([]string{"--config", "VMWareEngine-UDP-1194.ovpn", "--pull", "--script-security", "2"}, oArgs...)...)
	cmd.Dir = dst
	logger.V(8).Info("Command:", "command", cmd.Args)

	var data []byte
	if data, err = cmd.CombinedOutput(); err != nil {
		return errors.Wrapf(err, "Failure in command processing: %s", string(data))
	}

	logger.V(8).Info("Command output: ", "output", string(data))

	return nil
}

func copyZip(src string, dst string) error {
	archive, err := zip.OpenReader(src)
	if err != nil {
		return err
	}
	defer func(archive *zip.ReadCloser) {
		_ = archive.Close()
	}(archive)

	for _, f := range archive.File {
		filePath := filepath.Join(dst, f.Name)

		if !strings.HasPrefix(filePath, filepath.Clean(dst)+string(os.PathSeparator)) {
			return errors.New("invalid file path")
		}
		if f.FileInfo().IsDir() {
			err = os.MkdirAll(filePath, os.ModePerm)
			if err != nil {
				return err
			}
			continue
		}

		if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
			return err
		}

		dstFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			return err
		}

		fileInArchive, err := f.Open()
		if err != nil {
			return err
		}

		if _, err := io.Copy(dstFile, fileInArchive); err != nil {
			return err
		}

		_ = dstFile.Close()
		_ = fileInArchive.Close()
	}
	return nil
}
